# АНАЛИЗ ПРОБЛЕМ ПРОИЗВОДИТЕЛЬНОСТИ И БЕЗОПАСНОСТИ

Проведён детальный анализ кода в `/home/user/Opis/js/`

---

## ПРОБЛЕМЫ ПРОИЗВОДИТЕЛЬНОСТИ

### 1. НЕОПТИМАЛЬНЫЕ ЦИКЛЫ И ОПЕРАЦИИ DOM

#### Проблема: Перебор всех свойств window
**Файл:** `/home/user/Opis/js/uso.export.js`
**Строки:** 66-72
```javascript
for (let key in w) {
  if (w[key] && w[key].PDFDocument) {
    DEBUG.log('[USO_EXPORT] PDFDocument found in window.' + key);
    w.PDFDocument = w[key].PDFDocument;
    return w.PDFDocument;
  }
}
```
**Проблема:** Цикл перебирает ВСЕ свойства window, что может быть очень медленным. В большом приложении это может привести к значительным задержкам.
**Решение:** Использовать конкретные namespace или более узкий поиск.

---

#### Проблема: Полный перебор пикселей canvas
**Файл:** `/home/user/Opis/js/uso.export.js`
**Строки:** 125-134
```javascript
for (let i = 0; i < data.length; i += 4) {
  const r = data[i];
  const g = data[i + 1];
  const b = data[i + 2];
  if (r > 250 && g > 250 && b > 250) {
    whitePixels++;
  }
}
```
**Проблема:** Для большого canvas (например, 4000x3000) это означает ~12 млн итераций. Это может заморозить UI.
**Решение:** Использовать выборку пикселей (sampling) вместо полного перебора.

---

#### Проблема: Неэффективная проверка пустоты canvas
**Файл:** `/home/user/Opis/js/uso.export.js`
**Строки:** 408-430
```javascript
for (let y = h - 1; y >= 0; y--) {
  let hasContent = false;
  for (let x = 0; x < w; x += 5) {  // даже с шагом 5
    const idx = (y * w + x) * 4;
    // ... проверка пиксель
  }
  if (hasContent) {
    lastContentY = y;
    break;
  }
}
```
**Проблема:** Для canvas высотой 3000px это ~3000 итераций с вложенным циклом. Очень медленно.
**Решение:** Проверять не каждый пиксель, а блоками по 50-100px.

---

### 2. СИНХРОННЫЕ ОПЕРАЦИИ, БЛОКИРУЮЩИЕ UI

#### Проблема: html2canvas с scale: 2
**Файл:** `/home/user/Opis/js/uso.export.js`
**Строки:** 557-564
```javascript
const canvasC = await h2c(node, { 
  scale: 2,           // ВЫСОКОЕ КАЧЕСТВО = МЕДЛЕННО
  useCORS: true, 
  allowTaint: true, 
  backgroundColor: '#fff',
  logging: false,
  imageTimeout: 0
});
```
**Проблема:** 
- scale: 2 означает в 4 раза больше пикселей для обработки
- Для A4 страницы (794x1122) это создаёт canvas 1588x2244 = 3.5млн пикселей
- Синхронная обработка может заморозить браузер на 5-10 секунд
- imageTimeout: 0 означает бесконечное ожидание изображений

**Решение:** 
- Использовать scale: 1.5 вместо 2
- Установить imageTimeout: 5000
- Показывать progress bar

---

#### Проблема: Обработка файла без прогресса
**Файл:** `/home/user/Opis/js/uso.app.js`
**Строки:** 109-225
```javascript
fileInput.addEventListener('change', async function(e) {
  const file = e.target.files?.[0];
  // ... синхронные операции:
  const imgEl = await loadImageElement(blobUrl);
  const dataUrl = drawWithOrientationExact(imgEl, orientation);
  // ... ещё операции
```
**Проблема:** 
- Для больших файлов (40МБ) нет feedback для пользователя
- Может выглядеть как зависание браузера
- Особенно критично для HEIC файлов (требуют конвертацию)

**Решение:** Добавить progress indicator с информацией о этапе загрузки.

---

### 3. УТЕЧКИ ПАМЯТИ (Event Listeners без очистки)

#### Проблема: ResizeObserver без полной очистки
**Файл:** `/home/user/Opis/js/uso.canvas.js`
**Строки:** 694-719
```javascript
_wrapRO = new ResizeObserver(() => {
  // ... код
  _resizeTimeout = setTimeout(() => { ... }, 500);
});
_wrapRO.observe(wrap);
```
**Проблема:** 
- `_resizeTimeout` может остаться неочищенным при выгрузке страницы
- ResizeObserver может продолжать работать после удаления элемента
- Visual Viewport listeners не полностью очищаются

**Критично:** Строки 152-160 (visualViewport listeners)
```javascript
if (window.visualViewport) {
  vvHandler = U.util.throttle(...);
  window.visualViewport.addEventListener('resize', vvHandler);
  window.visualViewport.addEventListener('scroll', vvHandler);
}
// Может не удалиться, если fakeFs отключится нестандартно
```

---

#### Проблема: Event listeners на document
**Файл:** `/home/user/Opis/js/uso.canvas.js`
**Строки:** 851-858
```javascript
$(document).on('keydown.uso', function(e){
  // ... обработка
});
```
**Проблема:** Namespace 'uso' есть, но нет явного off() при очистке canvas.

---

#### Проблема: setTimeout/setInterval без очистки
**Файл:** `/home/user/Opis/js/uso.app.js`
**Строки:** 643-681
```javascript
autosaveTimer = setInterval(function(){
  // ... autosave
  localStorage.setItem(AUTOSAVE_KEY, json);
}, AUTOSAVE_INTERVAL);
```
**Проблема:** 
- Interval может работать бесконечно, даже если пользователь уходит со страницы
- Нет очистки при выгрузке страницы (нет window.addEventListener('beforeunload', ...))

---

### 4. ИЗБЫТОЧНЫЕ ПЕРЕРИСОВКИ CANVAS

#### Проблема: requestRenderAll в цикле
**Файл:** `/home/user/Opis/js/uso.canvas.js`
**Строки:** 494-505
```javascript
function rescaleAllMarkers(){
  const markers = getMarkersForCurrentImage();
  markers.forEach(rescaleMarker);  // каждый rescaleMarker вызывает setCoords()
  if (midline) { ... }
  mainCanvas.requestRenderAll();  // только один раз в конце - ХОРОШО
}
```
**Хорошо здесь**, но проблема может быть в других местах.

#### Проблема: Множественные операции в mouse:move
**Файл:** `/home/user/Opis/js/uso.canvas.js`
**Строки:** 902-908
```javascript
mainCanvas.on('mouse:move', function(opt){
  if (drawState && drawState.mode==='line'){
    const p = mainCanvas.getPointer(opt.e);
    drawState.lineObj.set({ x2:p.x, y2:p.y });
    drawState.lineObj.setCoords();
    mainCanvas.requestRenderAll();  // вызывается на КАЖДОЕ движение мыши!
  }
});
```
**Проблема:** requestRenderAll вызывается на каждое движение мыши, может привести к 60+ вызовов в секунду.
**Решение:** Использовать requestAnimationFrame для debounce.

---

### 5. БОЛЬШИЕ ФУНКЦИИ БЕЗ ОПТИМИЗАЦИИ

#### Проблема: Метод exportPDF
**Файл:** `/home/user/Opis/js/uso.export.js`
**Строки:** 798-904
Функция ~100 строк с множеством вложенных операций, включая:
- Загрузку библиотек
- Рендеринг HTML в canvas
- Разбиение на страницы
- Объединение PDF
- UI обновления

**Решение:** Разбить на меньшие функции для лучшей оптимизации и кеширования.

---

### 6. ОТСУТСТВИЕ DEBOUNCE/THROTTLE

#### Проблема: Нет throttle на режимах работы
**Файл:** `/home/user/Opis/js/uso.app.js`
**Строки:** 44-60
```javascript
modeSelect.addEventListener('change', function() {
  // ... переключение режима
  recompute();  // может быть вызвано много раз быстро
});
```

#### Проблема: Нет debounce на изменении материалов
**Файл:** `/home/user/Opis/js/uso.app.js`
**Строки:** 384-395
```javascript
$(document).on('change', 'input.uso-mat', function(){
  // ...
  recomputeDebounced();  // используется, ХОРОШО
});
```
**Хорошо здесь**, но есть проблемы в других местах.

#### Проблема: Форматирование телефона в input event
**Файл:** `/home/user/Opis/js/uso.app.js`
**Строки:** 556-593
```javascript
$('#uso-patient-phone').on('input paste', function(e){
  const self = this;
  setTimeout(() => {  // 10мс задержка
    let val = self.value;
    val = val.replace(/[^\d+]/g, '');
    // ... много операций
  }, 10);
});
```
**Проблема:** 
- Вызывается на каждый вводимый символ
- Много regex операций
- Может быть медленнее при быстром вводе

---

### 7. ДОПОЛНИТЕЛЬНЫЕ ПРОБЛЕМЫ ПРОИЗВОДИТЕЛЬНОСТИ

#### Проблема: Autosave пишет в localStorage каждые 30 сек
**Файл:** `/home/user/Opis/js/uso.app.js`
**Строки:** 665-670
```javascript
if (json.length > 1024 * 1024) {
  console.warn('[USO] Autosave data too large...');
  return;
}
localStorage.setItem(AUTOSAVE_KEY, json);
```
**Проблема:** 
- Пишет в localStorage даже если данные не изменились
- Для больших проектов это может замедлить браузер
- localStorage блокирует главный поток

**Решение:** Сравнивать с предыдущей версией и писать только при изменениях.

---

## ПРОБЛЕМЫ БЕЗОПАСНОСТИ

### 1. ИСПОЛЬЗОВАНИЕ innerHTML БЕЗ ЗАЩИТЫ

#### Проблема: innerHTML в buildPDFBlob
**Файл:** `/home/user/Opis/js/uso.export.js`
**Строки:** 543-545
```javascript
const node = document.createElement('div');
node.style.width='794px';
node.innerHTML = html;  // ⚠️ ОПАСНО если html не контролируется
```
**Уязвимость:** XSS - если `html` содержит user-controlled content, может быть выполнен JavaScript.
**Контекст:** `html` генерируется из `buildPDFHtml()` которая использует `split().join()` для подстановки, это может быть уязвимо.

**Пример уязвимого сценария:**
```javascript
// Если patient_name содержит: <img src=x onerror="alert('XSS')">
const html = tpl.split('{{patient_name}}').join(name);
node.innerHTML = html;  // XSS выполнится!
```

**Решение:** Использовать `textContent` для переменных или `appendChild` с защитой:
```javascript
// Вместо split/join использовать innerHTML для template + textContent для values
const safeInnerHTML = buildSafeHTML(tpl, {patient_name: name, ...});
node.innerHTML = safeInnerHTML;
```

---

#### Проблема: innerHTML в htmlToText
**Файл:** `/home/user/Opis/js/uso.export.js`
**Строки:** 906-909
```javascript
function htmlToText(html) {
  const div = document.createElement('div');
  div.innerHTML = html;  // ⚠️ Может содержать вредоносный код
```
**Уязвимость:** Если `html` содержит onload, onerror и т.д., они могут выполниться при доступе к элементам.

**Решение:** Использовать `DOMParser` с более безопасным режимом или sanitizer.

---

#### Проблема: innerHTML для UI элементов
**Файл:** `/home/user/Opis/js/uso.app.js`
**Строки:** 76-95
```javascript
modeInfo.innerHTML = `
  <div style="background: #f3e5f5; padding: 12px; border-radius: 4px; ...">
    <strong>📷 Режим простых фото ...</strong>
    ...
  </div>
`;
```
**Анализ:** 
- Этот HTML генерируется на сервере (в коде)
- Не содержит user-controlled данные
- **БЕЗОПАСНО**

---

#### Проблема: jQuery html() в preview
**Файл:** `/home/user/Opis/js/uso.app.js`
**Строки:** 538-540
```javascript
const html = await buildAllVariantSectionsTextOnlyHTML();
$('#uso-preview').html(html);  // ⚠️ Что это возвращает?
previewOverride = '';
```
**Анализ:** 
- `buildAllVariantSectionsTextOnlyHTML()` возвращает построенный HTML из `buildVariantSectionTZ()`
- `buildVariantSectionTZ()` использует `escapeHTML()` для переменных
- Хорошие практики, но стоит проверить все пути

---

### 2. XSS УЯЗВИМОСТИ

#### Проблема: Частичная защита от XSS
**Файл:** `/home/user/Opis/js/uso.export.js`
**Строки:** 284-288
```javascript
const esc = function(s){
  const div = document.createElement('div');
  div.textContent = String(s || '');
  return div.innerHTML;
};
```
**Хорошо:** Использует textContent вместо innerHTML для входных данных.
**Но:** Эта функция определена локально в `buildPDFHtml`, используется не везде.

#### Проблема: Несоответствующая escapeHTML в разных местах
**Файл:** `/home/user/Opis/js/uso.app.js`
**Строки:** 26-30
```javascript
function escapeHTML(s){
  const div = document.createElement('div');
  div.textContent = String(s || '');
  return div.innerHTML;
}
```
**Хорошо:** Функция есть.
**Но:** Не используется везде.

**Примеры плохого использования:**
**Файл:** `/home/user/Opis/js/uso.app.js`
**Строки:** 1143-1150
```javascript
parts.push(
  '<p>Здравствуйте, <b>'+escapeHTML(name||'')+'</b>.</p>'+
  // ... много других строк с escapeHTML
  '<p>Контакты пациента: '+escapeHTML(phoneMasked)+'</p>'
);
```
**Хорошо:** Используется escapeHTML.

**Но проблемные места:**
**Строки:** 1668-1673
```javascript
html = variants.map((v, i) => {
  const lc = v._lastCalc || {};
  return '<div ...>' +
         '<b>'+escapeHTML(v.title)+'</b><br>' +
         'Терапия: '+U.util.money(lc.therapy||0)+' ₽<br>' +
         // ...
```
**Анализ:** Хорошо используется escapeHTML для title.

---

### 3. ПРОБЛЕМЫ С ОБРАБОТКОЙ ПОЛЬЗОВАТЕЛЬСКОГО ВВОДА

#### Проблема: Ограничение размера файла не проверяется на сервере
**Файл:** `/home/user/Opis/js/uso.app.js`
**Строки:** 126-130
```javascript
if (file.size > 40 * 1024 * 1024) {
  alert('Файл слишком большой (>40 МБ)');
  e.target.value = '';
  return;
}
```
**Проблема:** 
- Проверка только на клиенте (легко обойти)
- Нет валидации расширения файла (только типа MIME, который может быть подделан)
- Нет проверки содержимого файла

**Решение:** Добавить серверную валидацию.

---

#### Проблема: HEIC конвертация использует внешний код
**Файл:** `/home/user/Opis/js/uso.app.js`
**Строки:** 135-149
```javascript
if (isHeic) {
  try {
    const h2a = await ensureHeic2Any();
    if (h2a) {
      processedFile = await h2a({ blob:file, toType:'image/jpeg', quality:0.98 });
    }
  } catch(err) {
    console.warn('[USO] HEIC convert failed:', err);
    alert('Не удалось конвертировать HEIC');
  }
}
```
**Проблема:** 
- Загружает внешнюю библиотеку из CDN (уязвимо для man-in-the-middle)
- Нет проверки, что результат - валидное JPEG

**Решение:** 
- Использовать HTTPS для загрузки библиотеки (уже сделано)
- Добавить проверку результата

---

### 4. НЕБЕЗОПАСНАЯ РАБОТА С ФАЙЛАМИ

#### Проблема: URL.createObjectURL не очищается всегда
**Файл:** `/home/user/Opis/js/uso.app.js`
**Строки:** 159-168
```javascript
const blobUrl = URL.createObjectURL(processedFile);
// ...
const imgEl = await loadImageElement(blobUrl);
// ...
URL.revokeObjectURL(blobUrl);  // ХОРОШО, очищается
```
**Анализ:** Хорошо - используется `revokeObjectURL`.

**Но проблема в других местах:**
**Файл:** `/home/user/Opis/js/uso.export.js`
**Строки:** 851-858
```javascript
const a = document.createElement('a');
a.href = url;
a.download = filenameBase + '.pdf';
document.body.appendChild(a);
a.click();
document.body.removeChild(a);
URL.revokeObjectURL(url);  // ХОРОШО
```
**Хорошо здесь**, но в строках 1586-1589:
```javascript
const url = URL.createObjectURL(blob);
const a = document.createElement('a'); 
a.href=url; 
a.download=name; 
document.body.appendChild(a); 
a.click(); 
document.body.removeChild(a);
URL.revokeObjectURL(url);  // ХОРОШО, но 100мс после click
```

---

#### Проблема: Нет проверки размера выходного файла
**Файл:** `/home/user/Opis/js/uso.export.js`
**Строки:** 660-663
```javascript
const blob = pdf.output('blob');
const name = (filenameBase||'otchet')+'.pdf';
DEBUG.log('[USO_EXPORT] PDF created, pages:', pageIndex, 'size:', Math.round(blob.size/1024), 'KB');
return { blob, name, pageIndex };
```
**Проблема:** 
- Нет проверки максимального размера PDF
- Для приложения с множественными снимками PDF может быть 500+ МБ
- Браузер может не суметь его скачать

**Решение:** Добавить проверку и разбиение на архив.

---

### 5. ОТСУТСТВИЕ ВАЛИДАЦИИ ДАННЫХ

#### Проблема: Отсутствие валидации рассчитанных значений
**Файл:** `/home/user/Opis/js/uso.calc.js`
**Строки:** 29-51
```javascript
function compute(cnt, jawSplits, selections, selectedMats){
  // ✅ Валидация входных параметров ЕСТЬ
  if (!cnt || typeof cnt !== 'object') {
    cnt = {};
  }
```
**Хорошо:** Валидация есть!

#### Проблема: Отсутствие валидации длины строк
**Файл:** `/home/user/Opis/js/uso.app.js`
**Строки:** 926-932
```javascript
function buildTextReport(htmlContent) {
  const name = ($('#uso-patient-name').val() || '').trim();
  const rawPhone = ($('#uso-patient-phone').val() || '').trim();
```
**Проблема:** 
- Нет проверки максимальной длины имени
- Может быть очень длинная строка, что замедлит систему

**Решение:** Добавить maxlength="50" на input и проверку на сервере.

---

### 6. ДОПОЛНИТЕЛЬНЫЕ ПРОБЛЕМЫ БЕЗОПАСНОСТИ

#### Проблема: Использование localStorage без защиты
**Файл:** `/home/user/Opis/js/uso.app.js`
**Строки:** 670-671
```javascript
localStorage.setItem(AUTOSAVE_KEY, json);  // Сохраняет полные данные локально
```
**Проблема:** 
- Данные пациента хранятся в открытом виде в localStorage
- Любой скрипт на сайте может их прочитать
- Если пользователь использует shared computer, данные видны

**Решение:** 
- Шифровать данные в localStorage
- Или хранить на сервере
- Добавить warning пользователю

---

#### Проблема: Fetch без CSRF защиты
**Файл:** `/home/user/Opis/js/uso.export.js`
**Строки:** 293-296
```javascript
if ((!tpl || tpl.length<=10) && url && typeof fetch === 'function') {
  const r = await fetch(url, { credentials:'same-origin' });
  if (r.ok) tpl = await r.text();
}
```
**Проблема:** 
- Fetch с credentials может быть уязвим для CSRF
- Нет проверки CSRF токена

**Решение:** Добавить CSRF токен в header для всех fetch запросов.

---

## РЕЙТИНГ КРИТИЧНОСТИ

### Критичные (High Priority):
1. ✅ XSS через innerHTML (uso.export.js:545)
2. ✅ Полный перебор пикселей canvas (uso.export.js:125-134) - блокирует UI
3. ✅ localStorage без защиты (uso.app.js:670) - утечка данных пациента
4. ✅ Размер файла проверяется только клиентом (uso.app.js:126-130)

### Средние (Medium Priority):
1. ✅ Нет debounce на mouse:move (uso.canvas.js:902-908)
2. ✅ ResizeObserver без полной очистки (uso.canvas.js:694-719)
3. ✅ Autosave пишет всегда (uso.app.js:665-670) - утечка памяти
4. ✅ HEIC конвертация из CDN (uso.app.js:138-149)

### Низкие (Low Priority):
1. ✅ Перебор window (uso.export.js:66-72)
2. ✅ Нет progress indicator (uso.app.js:109-225)
3. ✅ Форматирование телефона в input (uso.app.js:556-593)

